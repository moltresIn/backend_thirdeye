# camera/face_recognition.py

import cv2
import numpy as np
from deep_sort_realtime.deep_sort import nn_matching
from deep_sort_realtime.deep_sort.detection import Detection
from deep_sort_realtime.deep_sort.tracker import Tracker
import os
from datetime import date, datetime
import logging
import asyncio
import torch
from ultralytics import YOLO
from django.utils import timezone
from django.conf import settings
from asgiref.sync import sync_to_async
from django.contrib.auth import get_user_model
from .models import TempFace, SelectedFace
import face_recognition
from django.db.models import Count

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Configuration parameters
MAX_FACES_PER_ID = 15
FACE_SAVE_INTERVAL = 7
PROCESSING_INTERVAL = 1
MAX_COSINE_DISTANCE = 0.3
NN_BUDGET = 300
TRACKER_MAX_AGE = 100
FACE_MATCH_THRESHOLD = 0.6

class FaceRecognitionProcessor:
    def __init__(self, user=None):
        self.user = user
        self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
        logger.info(f"Using device: {self.device}")

        # Load YOLO model for face detection
        model_path = os.path.join(settings.BASE_DIR, 'yolov8m-face.pt')
        self.facemodel = YOLO(model_path).to(self.device)
        logger.info(f"YOLO model loaded on device: {self.device}")

        # Initialize DeepSORT tracker
        metric = nn_matching.NearestNeighborDistanceMetric("cosine", MAX_COSINE_DISTANCE, NN_BUDGET)
        self.tracker = Tracker(metric, max_age=TRACKER_MAX_AGE)
        logger.info("DeepSORT tracker initialized")

        # Configuration parameters and variables
        self.face_match_threshold = FACE_MATCH_THRESHOLD
        self.current_date = date.today()
        self.face_id_counter = 1
        self.face_id_mapping = {}
        self.frame_save_counter = {}
        self.available_face_ids = []
        self.frame_buffer = asyncio.Queue(maxsize=10)
        logger.info("FaceRecognitionProcessor initialized")

        # Initialize face encoder
        self.face_encoder = face_recognition.face_encodings
        logger.info("Face encoder initialized")

        # Start periodic processing task
        self.periodic_task = asyncio.create_task(self.periodic_processing())
        logger.info("Periodic processing task started")

    async def process_frame(self, frame):
        logger.debug("Processing new frame")
        await self.frame_buffer.put(frame)
        return await self.process_frame_from_buffer()

    async def process_frame_from_buffer(self):
        frame = await self.frame_buffer.get()
        faces = self.detect_faces(frame)  # Detect all faces
        logger.debug(f"Detected {len(faces)} faces")

        detections = [Detection(face[:4], face[4], self.generate_feature(face, frame)) for face in faces]
        logger.debug(f"Created {len(detections)} detections for tracker")

        self.tracker.predict()
        self.tracker.update(detections)
        logger.debug(f"Tracker updated with {len(self.tracker.tracks)} tracks")

        detected_faces = []
        for track in self.tracker.tracks:
            if not track.is_confirmed() or track.time_since_update > 1:
                continue

            bbox = track.to_tlbr()
            temp_face = await self.save_face_image(frame, track)  # Process each detected face

            if temp_face is None:
                continue

            cv2.rectangle(frame, (int(bbox[0]), int(bbox[1])), (int(bbox[2]), int(bbox[3])), (255, 0, 0), 2)
            cv2.putText(frame, temp_face.face_id, (int(bbox[0]), int(bbox[1]) - 10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)

            detected_faces.append({
                'id': temp_face.id,
                'face_id': temp_face.face_id,
                'last_seen': timezone.localtime(temp_face.last_seen).strftime('%I:%M %p'),
                'image_data': temp_face.image_data,
                'coordinates': {
                    'left': bbox[0],
                    'top': bbox[1],
                    'right': bbox[2],
                    'bottom': bbox[3]
                }
            })
            logger.debug(f"Processed face: {temp_face.face_id}")

        return frame, detected_faces

    def detect_faces(self, frame):
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.facemodel(frame_rgb, conf=0.3)  # Lowered confidence threshold to capture more faces

        faces = []
        for result in results:
            boxes = result.boxes
            for box in boxes:
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                confidence = box.conf.item()
                faces.append([x1, y1, x2 - x1, y2 - y1, confidence])

        logger.info(f"Detected faces: {len(faces)}")  # Log the number of faces detected
        return np.array(faces)

    def generate_feature(self, face, frame):
        x, y, w, h, _ = face.astype(int)
        face_roi = frame[y:y+h, x:x+w]
        if face_roi.size == 0:
            return np.zeros(128)

        face_roi = cv2.resize(face_roi, (96, 96))
        return face_roi.flatten() / 255.0

    def get_next_face_id(self):
        if self.available_face_ids:
            return self.available_face_ids.pop(0)

        today = date.today()
        if today != self.current_date:
            self.current_date = today
            self.face_id_counter = 1
            self.face_id_mapping.clear()

        face_id = f"unknown_{self.face_id_counter:03d}"
        self.face_id_counter += 1
        logger.info(f"Generated new face ID: {face_id}")
        return face_id

    async def save_face_image(self, frame, track):
        track_id = int(track.track_id)
        if track_id not in self.face_id_mapping:
            self.face_id_mapping[track_id] = self.get_next_face_id()
            self.frame_save_counter[track_id] = 0

        self.frame_save_counter[track_id] += 1

        if self.frame_save_counter[track_id] % FACE_SAVE_INTERVAL != 0:
            return None

        face_id = self.face_id_mapping[track_id]
        bbox = track.to_tlbr()
        h, w = frame.shape[:2]
        pad_w, pad_h = 0.2 * (bbox[2] - bbox[0]), 0.2 * (bbox[3] - bbox[1])
        x1, y1 = max(0, int(bbox[0] - pad_w)), max(0, int(bbox[1] - pad_h))
        x2, y2 = min(w, int(bbox[2] + pad_w)), min(h, int(bbox[3] + pad_h))

        face_img = frame[y1:y2, x1:x2]
        if face_img.size > 0:
            embedding = self.generate_face_embedding(face_img)
            if embedding is not None:
                embedding = embedding.tolist()  # Convert numpy array to list for storage
                try:
                    # Encode the face image as a byte array
                    face_img = cv2.imencode('.jpg', face_img)[1].tobytes()
                    matched_face = await sync_to_async(self.match_face)(embedding)
                    if matched_face:
                        # Update matched face
                        await self.create_update_selected_face(matched_face.face_id, face_img, embedding, 0, timezone.now())
                    else:
                        # Create new face
                        await self.create_update_selected_face(face_id, face_img, embedding, 0, timezone.now())
                    logger.info(f"Processed and stored face for {face_id}")
                    return TempFace(user=self.user, face_id=face_id, image_data=face_img, embedding=embedding)
                except Exception as e:
                    logger.error(f"Error processing face {face_id}: {str(e)}", exc_info=True)
                    return None

        return None

    async def create_update_selected_face(self, face_id, image_data, embedding, quality_score, last_seen):
        date_seen = last_seen.date()  # Move this line outside the try block
        try:
            # Ensure the image_data is contiguous
            if isinstance(image_data, np.ndarray) and not image_data.flags['C_CONTIGUOUS']:
                image_data = np.ascontiguousarray(image_data)
            
            # Decode the image data
            image = cv2.imdecode(np.frombuffer(image_data, np.uint8), cv2.IMREAD_COLOR)
            if image is None:
                raise ValueError("Failed to decode image data")
            
            blur_score = self.detect_blur(image)

            # Check for existing face entry with same face_id
            existing_faces = await sync_to_async(list)(
                SelectedFace.objects.filter(face_id=face_id, user=self.user).order_by('-last_seen')
            )

            if existing_faces:
                last_recorded_time = existing_faces[0].last_seen
                time_diff = (last_seen - last_recorded_time).total_seconds()

                # Only update if the time difference is less than a threshold, e.g., 5 seconds
                if time_diff < 5:
                    selected_face = existing_faces[0]
                    selected_face.image_data = cv2.imencode('.jpg', image)[1].tobytes()
                    selected_face.embedding = embedding
                    selected_face.quality_score = quality_score
                    selected_face.blur_score = blur_score
                    selected_face.last_seen = last_seen
                    selected_face.timestamp = timezone.now()
                    await sync_to_async(selected_face.save)()
                    action = "Updated"
                else:
                    # Create a new record with the same face_id but keep the old ones
                    selected_face = SelectedFace(
                        face_id=face_id,
                        user=self.user,
                        image_data=cv2.imencode('.jpg', image)[1].tobytes(),
                        embedding=embedding,
                        quality_score=quality_score,
                        blur_score=blur_score,
                        last_seen=last_seen,
                        timestamp=timezone.now()
                    )
                    await sync_to_async(selected_face.save)()
                    action = "Created new entry"
            else:
                # If no existing face is found, create a new entry
                selected_face = SelectedFace(
                    face_id=face_id,
                    user=self.user,
                    image_data=cv2.imencode('.jpg', image)[1].tobytes(),
                    embedding=embedding,
                    quality_score=quality_score,
                    blur_score=blur_score,
                    last_seen=last_seen,
                    timestamp=timezone.now()
                )
                await sync_to_async(selected_face.save)()
                action = "Created new entry"

            logger.info(f"{action} for face_id {face_id} on {date_seen}")
        except Exception as e:
            logger.error(f"Error creating/updating SelectedFace for {face_id} on {date_seen}: {str(e)}", exc_info=True)

    def match_face(self, embedding, threshold=None):
        if threshold is None:
            threshold = self.face_match_threshold
        selected_faces = SelectedFace.objects.filter(user=self.user)
        for face in selected_faces:
            if face.embedding:
                distance = np.linalg.norm(np.array(embedding) - np.array(face.embedding))
                if distance < threshold:
                    return face  # Return the matched SelectedFace object
        return None

    def generate_face_embedding(self, face_image):
        # Convert to RGB as face_recognition works with RGB images
        rgb_image = cv2.cvtColor(face_image, cv2.COLOR_BGR2RGB)
        encodings = face_recognition.face_encodings(rgb_image)
        if encodings:
            return encodings[0]
        return None

    def detect_blur(self, image):
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        return cv2.Laplacian(gray, cv2.CV_64F).var()

    async def rename_face(self, old_face_id, new_face_id):
        try:
            selected_faces = await sync_to_async(list)(
                SelectedFace.objects.filter(user=self.user, face_id=old_face_id)
            )
            
            if not selected_faces:
                logger.error(f"No SelectedFace found with face_id {old_face_id}")
                return
            
            for face in selected_faces:
                face.face_id = new_face_id
                face.is_known = True
                await sync_to_async(face.save)()

            self.available_face_ids.append(old_face_id)
            
            logger.info(f"Renamed face_id from {old_face_id} to {new_face_id} and marked as known")

        except Exception as e:
            logger.error(f"Error renaming face_id: {str(e)}", exc_info=True)

    async def periodic_processing(self):
        while True:
            try:
                logger.info("Starting periodic processing of temp faces...")
                await self.process_temp_faces()
                logger.info("Finished periodic processing of temp faces")
            except Exception as e:
                logger.error(f"Error in periodic processing: {str(e)}", exc_info=True)
            finally:
                await asyncio.sleep(PROCESSING_INTERVAL)

    async def process_temp_faces(self):
        logger.info("Retrieving unprocessed TempFaces")
        unprocessed_faces = await sync_to_async(list)(
            TempFace.objects.filter(processed=False).order_by('face_id', '-last_seen')
        )
        logger.info(f"Found {len(unprocessed_faces)} unprocessed TempFaces")

        current_face_id = None
        face_group = []

        for face in unprocessed_faces:
            if current_face_id != face.face_id:
                if face_group:
                    await self.process_face_group(face_group)
                current_face_id = face.face_id
                face_group = []

            face_group.append(face)

            if len(face_group) == MAX_FACES_PER_ID:
                await self.process_face_group(face_group)
                face_group = []

        if face_group:
            await self.process_face_group(face_group)

    async def process_face_group(self, face_group):
        if not face_group:
            return

        face_id = face_group[0].face_id
        logger.info(f"Processing face group for face_id: {face_id}")

        best_image, best_quality_score, best_embedding = None, -float('inf'), None
        last_seen = face_group[0].last_seen

        for face in face_group:
            image_data = await sync_to_async(lambda: face.image_data)()
            embedding = await sync_to_async(lambda: face.embedding)()
            if image_data and embedding:
                image = cv2.imdecode(np.frombuffer(image_data, np.uint8), cv2.IMREAD_COLOR)

                if image is None:
                    continue

                blur_score = self.detect_blur(image)
                angle_score = self.calculate_face_angle(image)

                quality_score = blur_score - (angle_score / 10)

                if quality_score > best_quality_score:
                    best_quality_score = quality_score
                    best_image = image_data
                    best_embedding = embedding
                    last_seen = face.last_seen

        if best_image is not None and best_embedding is not None:
            matched_face = await sync_to_async(self.match_face)(best_embedding)
            
            if matched_face:
                logger.info(f"Matched face_id: {matched_face.face_id}")
                await self.create_update_selected_face(matched_face.face_id, best_image, best_embedding, best_quality_score, last_seen)
            else:
                logger.info(f"No match found, creating or updating SelectedFace for face_id: {face_id}")
                await self.create_update_selected_face(face_id, best_image, best_embedding, best_quality_score, last_seen)

                # Delete all TempFace records after processing
        await sync_to_async(TempFace.objects.filter(face_id=face_id).delete)()
        logger.info(f"Deleted TempFace records for face_id: {face_id}")

    async def get_face_analytics(self):
        try:
            logger.info("Calculating face analytics...")

            # Total number of faces
            total_faces = await sync_to_async(SelectedFace.objects.filter(user=self.user).count)()

            # Number of known faces
            known_faces = await sync_to_async(SelectedFace.objects.filter(user=self.user, is_known=True).count)()

            # Number of unknown faces
            unknown_faces = total_faces - known_faces

            # Most common face IDs
            face_counts = await sync_to_async(
                lambda: SelectedFace.objects.filter(user=self.user)
                .values('face_id')
                .annotate(count=Count('id'))
                .order_by('-count')
            )()

            logger.info(f"Total faces: {total_faces}, Known faces: {known_faces}, Unknown faces: {unknown_faces}")
            logger.info(f"Face counts: {face_counts}")

            return {
                'total_faces': total_faces,
                'known_faces': known_faces,
                'unknown_faces': unknown_faces,
                'face_counts': list(face_counts)
            }
        except Exception as e:
            logger.error(f"Error getting face analytics: {str(e)}", exc_info=True)
            return None

